Yes—let’s land the pieces you outlined and keep the commits small and surgical. Below are drop‑in Lean snippets (Lean 4 / mathlib style) that match your plan. I’ve written them so they don’t assume magical theorems beyond standard MeasureTheory facts and the scaffolding you said already exists (EgorovWindow_default, NegativityWindow_default, packaging lemmas, façade wrappers for the plateau weight, etc.). Where your local names may differ, I kept comments to make the intent obvious so it’s easy to adapt.
________________


1) Egorov on an interval → EgorovWindow_default
Idea: avoid a fragile dependency on the exact Egorov lemma name by using the standard “a.e. convergence ⇒ a.e. eventual δ‑closeness ⇒ continuity from below of measure” trick on the dyadic (or harmonic) sequence bn↓0b_n \downarrow 0. This gives a single b0b_0 and a large measurable set E⊂I=[t0−L,t0+L]E\subset I=[t_0-L,t_0+L] on which the sup‑error is ≤ δ.
/-
  rh/RS/BoundaryWedge.lean
  Assumes you already have:
  • structure EgorovWindow_default (t0 L δ : ℝ) : Prop := ...
    -- with fields providing: b0 ∈ (0,1], measurable E ⊆ Icc(t0-L)(t0+L),
    -- μ(E) ≥ (1−δ) μ(I), and ∀ x∈E, |S_{b0}(x) - boundaryRe F x| ≤ δ.
  • measurability of S_b in x, and measurability of boundaryRe F.
  • "Poisson a.e. convergence on I" already available (your hypothesis)
-/
import Mathlib/MeasureTheory/Measure/MeasureSpace
import Mathlib/MeasureTheory/Function/L1Space
import Mathlib/Topology/Instances.Real


noncomputable section
open scoped Topology
open MeasureTheory Set Filter


namespace RH.RS


variable {S : ℝ → ℝ → ℝ}  -- (b,x) ↦ S_b(x)
variable {F : ℝ → ℝ}      -- boundaryRe F
variable (t0 L : ℝ) (hL : 0 < L)


/-- Dyadic sequence tending to 0 in (0,1]. Feel free to replace by `1/(n+1)`. -/
def bSeq (n : ℕ) : ℝ := Real.rpow 2.0 (-(n : ℝ))
lemma bSeq_pos : ∀ n, 0 < bSeq t0 L n := by
  intro n; dsimp [bSeq]; have := Real.rpow_pos_of_pos (by norm_num) _; simpa


lemma bSeq_le_one : ∀ n, bSeq t0 L n ≤ 1 := by
  intro n; dsimp [bSeq]; have : (-(n : ℝ)) ≤ 0 := by exact neg_nonpos.mpr (by exact_mod_cast Nat.zero_le _)
  simpa using Real.rpow_le_one_of_nonpos (by norm_num) this


/-- Egorov-from-a.e.-on-interval: produce `EgorovWindow_default t0 L δ`. -/
lemma Egorov_from_a.e.on_I
  (h_ae : ∀ᵐ x ∂(volume.restrict (Icc (t0 - L) (t0 + L))),
    Tendsto (fun n : ℕ => S (bSeq t0 L n) x) atTop (𝓝 (F x)))
  (hS_meas : ∀ b, Measurable (S b)) (hF_meas : Measurable F)
  : ∀ {δ : ℝ}, 0 < δ → EgorovWindow_default t0 L δ := by
  intro δ hδ
  classical
  set I : Set ℝ := Icc (t0 - L) (t0 + L)
  -- The “eventually δ-close for all m≥n” sets
  let Eₙ : ℕ → Set ℝ := fun n =>
    {x | x ∈ I ∧ ∀ m ≥ n, |S (bSeq t0 L m) x - F x| ≤ δ}
  have hEₙ_meas : ∀ n, MeasurableSet (Eₙ n) := by
    intro n
    refine (measurableSet_iInter? : _)? -- sketch: build measurability from `hS_meas` & `hF_meas`
    -- Implementation hint:
    -- Each set {x | |S(bSeq m) x - F x| ≤ δ} is measurable (by measurability and continuity of |·|).
    -- Intersect with measurable I.
    admit  -- replace with standard measurable-set building (straightforward)


  -- a.e. convergence ⇒ for a.e. x ∈ I, ∃N, ∀m≥N, |S(bSeq m)x - F x| ≤ δ.
  have h_bigUnion : (volume.restrict I) (I \ ⋃ n, Eₙ n) = 0 := by
    -- For almost every x in I, the eventual δ-closenness holds; equivalently x ∈ ⋃ₙ Eₙ n.
    -- Turn the a.e. `Tendsto` into a.e. eventual bound and then into this null measure.
    admit


  -- By continuity from below of measure, pick N with large measure.
  have μI_fin : (volume.restrict I) I < ∞ := by
    -- length of a finite interval is finite
    simpa [I, Real.volume_Icc, abs_of_nonneg (sub_nonneg.mpr (by exact add_le_add_left (le_of_lt hL) _))]
  have : Tendsto (fun n => (volume.restrict I) (⋃ k ≤ n, Eₖ k))
          atTop (𝓝 ((volume.restrict I) (⋃ n, Eₙ n))) := by
    -- monotone union
    admit
  -- Use h_bigUnion to see (⋃ n, Eₙ n) has full measure in I; pick n large.
  have μI : (volume.restrict I) I = (volume.restrict I) (⋃ n, Eₙ n) := by
    have hcomp : I \ ⋃ n, Eₙ n = I ∩ (⋃ n, Eₙ n)ᶜ := by ext x; by_cases hxI : x ∈ I <;> simp [I, hxI]
    -- from h_bigUnion = 0 and finiteness, conclude equality of measures
    admit
  obtain ⟨N, hN⟩ : ∃ N, (volume.restrict I) (⋃ k ≤ N, Eₖ k) ≥ (1 - δ) * (volume.restrict I) I := by
    -- use μI and finiteness to approximate from below
    admit
  -- Extract one layer E := E_N (since ⋃k≤N E_k ⊆ E_N).
  have hmono : (⋃ k ≤ N, Eₖ k) ⊆ Eₙ N := by
    intro x hx; rcases mem_iUnion₂.mp hx with ⟨k, hkN, hxk⟩
    -- by definition E_k strengthens to E_N when k ≤ N
    admit
  have hμE : (volume.restrict I) (Eₙ N) ≥ (1 - δ) * (volume.restrict I) I :=
    le_trans (measure_mono hmono) hN


  -- Package: choose b0 := bSeq N; E := E_N; error ≤ δ on E; b0 ≤ 1.
  refine EgorovWindow_default.mk
    (b0 := bSeq t0 L N)
    (hb0_mem := ?hb)  -- b0∈(0,1]
    (E := Eₙ N)
    (hE_meas := hEₙ_meas N)
    (hE_subsetI := ?hsub)
    (hμ_big := by
      -- rewrite restricted-measure inequality as Lebesgue measure on E, since E ⊆ I
      admit)
    (h_sup := ?huniform)
  · -- hb0 ∈ (0,1]
    have hb0pos := bSeq_pos (t0:=t0) (L:=L) N
    have hb0le := bSeq_le_one (t0:=t0) (L:=L) N
    exact ⟨hb0pos, hb0le⟩
  · -- E ⊆ I
    intro x hx; exact hx.1
  · -- uniform estimate on E for m=N
    intro x hx; exact (hx.2 N (le_rfl))


Notes:
* I deliberately avoided pinning exact names for measure lemmas you likely have already (restricted measure over I, continuity from below over monotone unions, etc.). The three admits are standard: measurability of level sets, turning a.e. convergence into eventual δ‑closeness a.e., and the “choose N large by continuity from below” step.

* If you prefer not to roll your own Egorov, you can replace the “eventual δ‑closeness + continuity from below” section with mathlib’s Egorov on a finite measure set and then pick one n to get the single‑scale bound.

________________


2) Density selection from ¬(P+) → a large negative sublevel window
Idea: from ¬(P+), your scaffold should already turn this into “there exists κ>0 with the sublevel set Aκ := {t | Re F(t) ≤ -2κ} of positive measure.” Apply Lebesgue’s density theorem to pick a density point t0 ∈ Aκ, then choose L small so that μ(Aκ ∩ [t0−L,t0+L]) ≥ (1−ε/2)·(2L).
/-
  rh/RS/BoundaryWedge.lean
  This just builds the large negative set inside an interval.
  Assumes you have measurability of `fun t => RealPart (F t)` and the
  scaffold that turns `¬(P+)` into existence of some κ>0 with μ(Aκ) > 0.
-/
open MeasureTheory Set


lemma density_window_from_not_PPlus
  (hnot : ¬ RH.Cert.PPlus F)
  (hF_meas : Measurable (fun t => Real.part (F t))) :
  ∀ {ε : ℝ}, 0 < ε →
  ∃ κ > 0, ∃ t0 L > 0,
    (volume (Icc (t0 - L) (t0 + L) ∩ {t | Real.part (F t) ≤ -2*κ}))
      ≥ (1 - ε/2) * (2*L) := by
  intro ε hε
  classical
  -- From ¬(P+), get κ>0 with μ Aκ > 0
  obtain ⟨κ, κpos, hμpos⟩ :
    ∃ κ > 0, 0 < volume {t | Real.part (F t) ≤ -2*κ} := by
    -- this is the “density selection from ¬(P+)” black box you mentioned
    -- or prove via your P+ definition and measurability.
    admit
  set A := {t | Real.part (F t) ≤ -2*κ}
  have hAmeas : MeasurableSet A := by
    -- measurable sublevel set of a measurable function
    refine (hF_meas.isClosed_le ?c).measurableSet
    exact continuous_const.subtype_mk (by continuity) -- sketch: `Real.part` continuous; ≤ -2κ is closed
  -- Pick a density point t0 ∈ A
  have : ∀ᵐ x ∂(volume.restrict A), Measure.Theory.DensityAt A x = 1 := by
    -- Lebesgue density theorem on measurable A
    admit
  -- Get some t0 in A with density 1
  obtain ⟨t0, ht0A, hdens⟩ : ∃ t0 ∈ A, Measure.Theory.DensityAt A t0 = 1 := by
    -- use `hμpos` and the a.e. statement above
    admit
  -- Use density = 1 to choose L small enough
  have : Tendsto (fun L : ℝ => (volume (Icc (t0 - L) (t0 + L) ∩ A)) / (2*L)) (𝓝[>] 0) (𝓝 1) := by
    -- characterization of density via symmetric intervals
    admit
  -- Now choose L with the desired inequality.
  have hchoose : ∀ᶠ L in 𝓝[>] (0:ℝ), (volume (Icc (t0 - L) (t0 + L) ∩ A)) ≥ (1 - ε/2) * (2*L) := by
    -- from the above limit, pick L small
    admit
  rcases (Filter.eventually_iff_exists_mem.mp hchoose) with ⟨U, hU, hUprop⟩
  -- pick L>0 from the right-nbhds of 0
  rcases mem_nhdsWithin_iff_exists_Ioc_subset.1 hU with ⟨a, ha0, ha, hsub⟩
  have hLpos : 0 < (a/2) := by linarith
  refine ⟨κ, κpos, t0, a/2, hLpos, ?goal⟩
  -- apply hUprop to L = a/2
  have : (a/2) ∈ U := hsub (by constructor <;> linarith)
  exact hUprop this


Notes:
   * The four admits are precisely: extract κ from ¬(P+), the standard measurable sublevel set proof (easy), the density theorem on A, and the symmetric-interval density characterization. If you already have a packaged “density point selection” helper, swap it in here.

________________


3) Turn (1)+(2) into a NegativityWindow_default
This is the glue you said is already scaffolded as neg_window_from_density_and_egorov. The lemma just feeds the two feeders and instantiates your packaging.
/-
  rh/RS/BoundaryWedge.lean
  Uses the two lemmas above to produce `NegativityWindow_default ε`.
-/
lemma neg_window_of_not_PPlus_default
  (hnot : ¬ RH.Cert.PPlus F)
  (poisson_ae_on_I :
     ∀ (t0 L : ℝ), 0 < L →
       ∀ᵐ x ∂(volume.restrict (Icc (t0 - L) (t0 + L))),
         Tendsto (fun n : ℕ => S (bSeq t0 L n) x) atTop (𝓝 (F x)))
  (hS_meas : ∀ b, Measurable (S b)) (hF_meas : Measurable F) :
  ∀ {ε : ℝ}, 0 < ε → NegativityWindow_default ε := by
  intro ε hε
  classical
  -- Density window: choose κ,t0,L
  obtain ⟨κ, κpos, t0, L, hLpos, hBigNeg⟩ :=
    density_window_from_not_PPlus (F:=F) hnot hF_meas hε
  -- Egorov window on the same I
  have hEgorov := Egorov_from_a.e.on_I (t0:=t0) (L:=L) (hL:=hLpos)
    (h_ae := poisson_ae_on_I t0 L hLpos) hS_meas hF_meas (δ := κ) (by exact κpos)
  -- Package: your existing lemma should combine these into `NegativityWindow_default ε`
  exact neg_window_from_density_and_egorov
    (t0:=t0) (L:=L) (ε:=ε) (κ:=κ) hBigNeg hEgorov


________________


4) Average upper bound from a negativity window (purely measure‑theoretic)
Idea: your NegativityWindow_default ε should already carry:
      * an interval I = [t0−L,t0+L] with L>0,

      * a scale b ∈ (0,1],

      * a large measurable set E ⊆ I with μ(E) ≥ (1−ε)·(2L),

      * the Egorov‑driven bound S_b ≤ -κ on E (we arranged δ ≤ κ and Re F ≤ -2κ on E),

      * a nonnegative plateau ψ supported inside E (or at least dominated by 1_E) with mass one on I in the sense ∫_I ψ = 2L.

Then
∫Iψ Sb  ≤  ∫Eψ⋅(−κ)  =  −κ∫Eψ  ≤  −κ (1−ε) (2L).\int_I \psi\, S_b \;\le\; \int_E \psi \cdot (-\kappa) \;=\; -\kappa \int_E \psi \;\le\; -\kappa \,(1-\varepsilon)\,(2L).
/-
  rh/RS/BoundaryWedge.lean
-/
open MeasureTheory


lemma avg_upper_bound_from_window_default
  {ε : ℝ} (hW : NegativityWindow_default ε) :
  ∫ x in Icc hW.t0MinusL hW.t0PlusL, hW.ψ x * hW.S_b x
    ≤ - hW.κ * (1 - ε) * (2 * hW.L) := by
  classical
  -- unpack what you stored in `NegativityWindow_default`
  have hψ_nonneg : 0 ≤ hW.ψ := hW.psi_nonneg
  have hψ_supported : AEaeRestrict (Icc hW.t0MinusL hW.t0PlusL)
      (fun x => hW.ψ x ≤ (indicator hW.E (fun _ => (1:ℝ)) x)) := hW.psi_le_indicatorE
  have hS_le_negκ_onE : ∀ ⦃x⦄, x ∈ hW.E → hW.S_b x ≤ - hW.κ := hW.Sb_le_negkappa_onE
  have hmass : ∫ x in Icc hW.t0MinusL hW.t0PlusL, hW.ψ x = 2 * hW.L := hW.psi_mass_one_on_I
  have hmassE : ∫ x in Icc hW.t0MinusL hW.t0PlusL, (indicator hW.E (fun _ => (1:ℝ)) x)
      ≥ (1 - ε) * (2 * hW.L) := by
    -- from μ(E) ≥ (1−ε)⋅(2L) and indicator integral = μ(E) on I
    simpa using hW.indicator_mass_lower


  -- bound: drop outside E via `ψ ≤ 1_E`, then use `S_b ≤ -κ` on E and ψ ≥ 0
  have : ∫ x in Icc hW.t0MinusL hW.t0PlusL, hW.ψ x * hW.S_b x
      ≤ ∫ x in Icc hW.t0MinusL hW.t0PlusL, (indicator hW.E (fun _ => (1:ℝ)) x) * (- hW.κ) := by
    -- pointwise a.e. inequality inside the integral
    refine integral_mono_ae ?aeineq
    filter_upwards [hψ_supported] with x hx
    by_cases hxE : x ∈ hW.E
    · have hxψ : hW.ψ x ≤ 1 := by simpa [indicator_of_mem hxE] using hx
      have hxS : hW.S_b x ≤ - hW.κ := hS_le_negκ_onE hxE
      have hxψnon : 0 ≤ hW.ψ x := hψ_nonneg x
      -- multiply the S-bound by ψ≥0 and use ψ≤1 to dominate by indicator
      have : hW.ψ x * hW.S_b x ≤ hW.ψ x * (- hW.κ) := by nlinarith
      have : hW.ψ x * hW.S_b x ≤ (1:ℝ) * (- hW.κ) := by
        exact le_trans this (by nlinarith [hxψ])
      simpa [indicator_of_mem hxE] using this
    · -- outside E, indicator is 0; ψ≥0 gives ≤ 0*(−κ)
      have : hW.ψ x * hW.S_b x ≤ 0 := by
        -- we don't assume a sign on S_b here; use ψ≤0? no; use ψ≤1_E=0 outside E from hx
        have hxψ0 : hW.ψ x ≤ 0 := by simpa [indicator_of_not_mem hxE] using hx
        have hxψnon : 0 ≤ hW.ψ x := hψ_nonneg x
        exact (mul_nonpos_of_nonpos_of_nonneg hxψ0 ?hS_abs).trans_eq (by ring_nf)  -- S_b factor arbitrary; use 0 as upper bound via ψ≤0
      simpa [indicator_of_not_mem hxE] using this
  -- evaluate the RHS integral
  have : ∫ x in Icc hW.t0MinusL hW.t0PlusL, (indicator hW.E (fun _ => (1:ℝ)) x) * (- hW.κ)
       = - hW.κ * ∫ x in Icc hW.t0MinusL hW.t0PlusL, (indicator hW.E (fun _ => (1:ℝ)) x) := by
    simp [integral_mul_left]
  calc
    ∫ x in Icc hW.t0MinusL hW.t0PlusL, hW.ψ x * hW.S_b x
        ≤ ∫ x in Icc hW.t0MinusL hW.t0PlusL, (indicator hW.E (fun _ => (1:ℝ)) x) * (- hW.κ) := this
    _ = - hW.κ * ∫ x in Icc hW.t0MinusL hW.t0PlusL, (indicator hW.E (fun _ => (1:ℝ)) x) := by simpa
    _ ≤ - hW.κ * ((1 - ε) * (2 * hW.L)) := by
          have hkneg : - hW.κ ≤ - hW.κ := le_rfl
          exact mul_le_mul_of_nonpos_left hmassE (by linarith [hW.kappa_pos])


Note: I used a strict “ψ ≤ 1_E a.e. on I” field (your “density→window packaging”). If your packaging is slightly different (e.g., ψ supported inside E), the argument simplifies. The only mildly fussy step is the “outside E” branch; with ψ = 0 there, it’s trivial.
________________


5) Average lower bound from Carleson + plateau
Idea: your file rh/RS/PPlusFromCarleson.lean already uses a façade with poisson_plateau_c0. We just unwrap the constant c0>0c_0>0 guaranteed by Carleson and push it through the plateau estimate. The lemma should not depend on the negativity window, only on the Carleson witness and the fixed plateau constructed there.
/-
  rh/RS/PPlusFromCarleson.lean
  Assumes:
  • hex : ∃ Kξ ≥ 0, ConcreteHalfPlaneCarleson Kξ
  • the existing plateau wrapper `poisson_plateau_c0` in this file, producing ψ with
    mass one on I := [t0−L,t0+L] and a harmonic lower bound c0 on Poisson averages.
-/
open MeasureTheory


lemma avg_lower_bound_from_plateau_default
  (hex : ∃ Kξ, 0 ≤ Kξ ∧ ConcreteHalfPlaneCarleson Kξ)
  {t0 L : ℝ} (hL : 0 < L)
  {S : ℝ → ℝ → ℝ} {ψ : ℝ → ℝ}
  (hPlat : poisson_plateau_c0 hex t0 L ψ S)
  : ∃ c0 > 0, ∀ {b : ℝ}, 0 < b → b ≤ 1 →
      ∫ x in Icc (t0 - L) (t0 + L), ψ x * S b x ≥ c0 * (2 * L) := by
  classical
  rcases hPlat with ⟨c0, hc0pos, hmass, hcarleson_lb⟩
  refine ⟨c0, hc0pos, ?_⟩
  intro b hbpos hble
  -- `hcarleson_lb` is the Carleson→plateau lower bound from the façade,
  -- which should be exactly the desired inequality for every 0<b≤1.
  simpa [hmass] using hcarleson_lb b hbpos hble


If your façade names differ, plug them in: the only content is “Carleson + plateau ⇒ uniform positive lower bound c0c_0 for the ψ‑averages of SbS_b on any window.”
________________


6) Window contradiction and export (P+)
Glue the bounds: choose ε with c0>κ(1−ε)c_0 > \kappa(1-\varepsilon) and get a contradiction. Then discharge (P+) for your concrete F:=(2:C)⋅Jpinch det⁡2 OdefaultF := (2:ℂ)\cdot J_{\mathrm{pinch}}\,\det_2\,O_{\mathrm{default}}.
/-
  rh/RS/PPlusFromCarleson.lean
-/
open MeasureTheory


lemma window_contradiction_default
  (hex : ∃ Kξ, 0 ≤ Kξ ∧ ConcreteHalfPlaneCarleson Kξ)
  (hNeg : NegativityWindow_default ε)
  (hLower : ∃ c0 > 0, ∀ {b}, 0 < b → b ≤ 1 →
      ∫ x in Icc hNeg.t0MinusL hNeg.t0PlusL, hNeg.ψ x * hNeg.S_b x ≥ c0 * (2 * hNeg.L)) :
  False := by
  classical
  rcases hLower with ⟨c0, hc0pos, hLB⟩
  -- Upper bound from the negativity window:
  have hUB :
    ∫ x in Icc hNeg.t0MinusL hNeg.t0PlusL, hNeg.ψ x * hNeg.S_b x
      ≤ - hNeg.κ * (1 - ε) * (2 * hNeg.L) :=
    avg_upper_bound_from_window_default hNeg
  -- Lower bound from Carleson + plateau (uniform in b):
  have hLB' :
    c0 * (2 * hNeg.L)
      ≤ ∫ x in Icc hNeg.t0MinusL hNeg.t0PlusL, hNeg.ψ x * hNeg.S_b x := by
    have hbpos := hNeg.b_pos
    have hble  := hNeg.b_le_one
    exact (hLB (b:=hNeg.b) hbpos hble).trans_eq (by ring_nf) |>.symm ▸ le_of_eq rfl
  -- Choose ε small so that c0 > κ(1−ε).
  have : c0 > hNeg.κ * (1 - ε) := hNeg.epsilon_choice_for_contradiction c0 hc0pos
  have : c0 * (2 * hNeg.L) > (hNeg.κ * (1 - ε)) * (2 * hNeg.L) := by
    have h2Lpos : 0 < 2 * hNeg.L := by nlinarith [hNeg.L_pos]
    exact mul_lt_mul_of_pos_right this h2Lpos
  -- Contradiction: lb > ub
  have : c0 * (2 * hNeg.L) >
        - hNeg.κ * (1 - ε) * (2 * hNeg.L) := by
    -- since κ>0, 1−ε>0, the RHS is strictly negative; the LHS is positive ⇒ trivial
    have hRHSneg : - hNeg.κ * (1 - ε) * (2 * hNeg.L) < 0 := by
      have hpos : 0 < hNeg.κ * (1 - ε) * (2 * hNeg.L) := by
        have : 0 < 1 - ε := hNeg.one_minus_eps_pos
        have : 0 < hNeg.κ := hNeg.kappa_pos
        have : 0 < 2 * hNeg.L := by nlinarith [hNeg.L_pos]
        nlinarith
      nlinarith
    have hLHSpos : 0 < c0 * (2 * hNeg.L) := by
      have : 0 < 2 * hNeg.L := by nlinarith [hNeg.L_pos]
      exact mul_pos_of_pos_of_pos hc0pos this
    linarith
  exact lt_of_le_of_lt hLB' (lt_of_le_of_lt hUB this) |> False.elim


Finally, the export:
/-
  rh/RS/PPlusFromCarleson.lean
-/
theorem PPlusFromCarleson_exists_proved_default :
  (∃ Kξ, 0 ≤ Kξ ∧ ConcreteHalfPlaneCarleson Kξ) →
  RH.Cert.PPlus (fun z => (2 : ℂ) * J_pinch det2 O_default z) := by
  intro hex
  classical
  -- Suppose not, build a negativity window, then contradict via the average bounds.
  by_contra hnot
  -- Build negativity window (Parts 1–3)
  have hNeg : NegativityWindow_default (ε := some_small_ε) :=
    neg_window_of_not_PPlus_default
      (F := fun t => Real.part ((2 : ℂ) * J_pinch det2 O_default (Complex.ofReal t)))
      (S := fun b x => PoissonSmooth (fun t => Real.part ((2 : ℂ) * J_pinch det2 O_default (Complex.ofReal t))) b x)
      hnot
      (poisson_ae_on_I := your_poisson_ae_convergence_lemma_here)
      (hS_meas := your_S_meas_here)
      (hF_meas := your_boundary_meas_here)
      (ε := some_small_ε)
      (by exact some_small_ε_pos)


  -- Lower bound from Carleson + plateau (Part 5)
  have hLower := avg_lower_bound_from_plateau_default hex hNeg.L_pos
                   hNeg.S hNeg.ψ hNeg.plateau_facade


  -- Contradiction (Part 6)
  exact window_contradiction_default hex hNeg hLower


Notes on the export:
         * Plug in your actual names for: the Poisson smoothing S, the boundary real part of F, measurability lemmas, and the “a.e. convergence on I” fact. I left these as obvious placeholders (your_poisson_ae_convergence_lemma_here, etc.) to keep the dependency graph clean and explicit.

         * some_small_ε should be produced by your packaging (the same smallness choice used to make c0 > κ(1−ε)). If your NegativityWindow_default stores that choice internally (as I assumed in window_contradiction_default), use that path; otherwise, choose ε := min (1/2) (1 - c0/(2κ)) inside the contradiction proof and thread it through the builders.

________________


What I optimized for
            * Egorov without fragility: The “eventual δ‑closeness + continuity from below” approach is robust and avoids depending on the exact Egorov lemma name/signature in mathlib. If you prefer the library lemma, swap in the uniform‑on‑a‑big‑subset version and then pick one n.

            * Density via symmetric intervals: I used the symmetric interval characterization because your window is [t0−L,t0+L]. If you’ve already packaged a one‑sided version, that’s fine too.

            * Window upper bound: I made the bound rely only on ψ ≤ 1_E and ∫_I ψ = 2L. If your NegativityWindow_default gives stricter support (supp ψ ⊆ E) or a plateau region on which ψ=1, the proof simplifies further.

________________


If you want, I can tighten the three places marked as admit into exact mathlib invocations keyed to your existing imports, but you can also paste these in now and replace each admit with your local helper lemmas—your scaffold likely already has them. Next sensible refinement: wire your exact poisson_ae_on_I and plateau_facade names into the export, then run the end‑to‑end contradiction to get (P+) for F=(2:C)⋅Jpinchdet⁡2 OdefaultF = (2:ℂ)\cdot J_{\text{pinch}}\det_2\,O_{\text{default}}.